# 뷰
## 개념
* 다른 테이블을 기반으로 만들어진 가상 테이블(실제 데이터 저장x)
* SQL 만 저장 
	* 어떻게 저장되어 있는거지? 
	* 뷰를 조회할 때마다 옵티마이저에서 뷰를 생성할 때 저장해 놓은 select 문이 날라가는 형식
## 활용
* 일반 테이블처럼 원하는 데이터를 검색할 수 있음
	* 뷰에 대한 select 문이 내부적으로는 기본 테이블에 대한 select 문으로 변환되어 수행되기 때문 
[image:591926A0-EAB1-403B-855D-DBA3EE633B3F-10279-000014A857326FA4/9970244E5F1E598D18.png]
* 뷰에 대한 삽입,수정,삭제 연산이 가능하지만(모든 뷰에서 가능x) 기본 테이블도 따라 변화함 
	* 기본 테이블의 기본키 속성을 포함하지 않는 뷰에서는 불가능 -> 어떤 레코드에 대한 수정, 삭제 연산인지 명확히 구분할 수 없기에 
	* 집계 함수로 계산된 값이 포함된 뷰 
## 그럼 왜 사용하지? 목적
1. 질의문을 좀 더 쉽게 작성
특정 조건을 만족하는 레코드들로 뷰를 만들어놓으면, 사용자가 where 절 없이 뷰를 검색해도 특정 조건을 만족하는 데이터를 검색 가능 
GROUP BY, 집계 함수, 조인 등을 이용해 뷰를 만들면 복잡한 SQL 문을 작성하지 않아도 select 절과 from 절만으로 원하는 데이터 검색 가능
* 그러면 성능면에서 문제는 없는가?
	* 뷰가 sql 만 저장하고 있기에 그냥 쿼리문을 날리는 것과 속도차이는 특별히 나지 않는다! 
2. 데이터의 보안 유지에 도움
여러 사용자의 요구에 맞는 다양한 뷰를 미리 정의해두고 사용자가 자신에게 제공된 뷰를통해서만 데이터에 접근하도록 권한을 설정하면 뷰에 포함되지 않은 데이터를 사용자로부터 보호할 수 있음
* ex. schema나 user로 구성된 database가 있는데, 특정 유저가 A라는 스키마의 테이블을 보는 권한이 없고, 더불어 보안상 봐서도 안된다라고 가정 한 상태에서, 그 유저가 A 스키마내 특정 테이블의 어떤 정보는 업무상 꼭 필요하다 할때, 이럴때 view를 생성하여 꼭 필요한것만 보여주고, 전체 정보는 공개하지 않도록 할 수 있 (with read only 라는 옵션 제공) 
* 권한 설정에 대하여…
## 단점
* 뷰에 인덱스를 구성할 수 없음
* 뷰를 포함하여 뷰를 만든 경우 연관 뷰를 삭제하면 생성된 뷰도 삭제
* 한번 정의된 뷰는 수정 불가 
## 단순 뷰 vs 복합 뷰
### 단순뷰
* 하나의 기본 테이블에서 만든 뷰
* 그룹 함수의 사용이 불가능 
* distinct 사용이 불가능
* DML(데이터 조작어) 사용 가능 
### 복합뷰
* 여러개의 기본 테이블에서 만든 뷰(join)
* 그룹 함수 사용 가능
* distinct 사용 가능 
* DML 사용 불가능
### 옵티마이저에서 뷰 ~ 
* 아래와 같은 view 생성문이 존재
```sql
SELECT name,
       money_received,
       money_sent,
       (money_received - money_sent) AS balance,
       address,
 …
  FROM table_customers c
  JOIN accounts_table a
    ON a.customer_id = c.customer_id
```
* 뷰를 활용하여 sql 실행
```sql
SELECT name,
       balance
  FROM accounts_view;
```
* dbms 옵티마이저가 인식하는 sql은? 
```sql
SELECT name,
       balance
  FROM (SELECT name,
               money_received,
               money_sent,
               (money_received - money_sent) AS balance,
               address,
 …
          FROM table_customers c JOIN accounts_table a
               ON a.customer_id = c.customer_id        );
```
PS. 스프링에서 뷰를 사용한다면.. 일반 테이블과 똑같이 @Entity를 사용하면 됨 
## Materialized View (oracle에 존재) 
* 원천 테이블이나 조인된 테이블에서 집계되거나 결합된 데이터로 구성된 미리 계산된 테이블 
* 요약 또는 집계 테이블이라고 함 
* 물리적으로 존재하는 테이블 -> data 가 일정 공간을 차지하고 있음 
* 자주사용되는 View의 결과를 디스크에 저장해서 Query 속도를 향상시키는 개념
	*  어떤 결과를 뽑아 내는 쿼리가 너무나도 빈번히 사용 될 경우, Query 실행 시간의 수행속도 향상을위하여 , 여러 가지의 Aggregate View를 두어, 미리 비용이 많이 드는 조인이나, Aggregate Operation 을 처리하여야 하는 SQL을 위해, 데이터베이스의 한 테이블로 저장 하며, 그 테이블을 조회 하도록 하는 것
### 특징 
* 쿼리 수행속도 향상
* dba 가 프로그램에 영향을 끼치지 않고 언제든지 생성 및 제거가 가능 
* 실행의 결과 행과 뷰 정의 모두 저장이 되고, 실행 결과 행으로 만들어진 테이블은 일정 공간을 차지
### 일반 뷰와의 차이점
* MView 의 결과값은 물리적으로 존재하지만 일반 view의 결과값은 물리적으로 존재하지 않음
* 일반 뷰는 단지 쿼리 정보가 딕셔너리에 저장되어 있고 사용될 때 그 sql이 다시 실행되는 것이기에 속도가 느림 

