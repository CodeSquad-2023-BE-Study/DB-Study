# Primary Key
## 특징
MySQL 에서 pk는 레코드의 저장 위치를 결정 -> pk가 유사한 레코드들끼리 묶어서 저장 -> `클러스터 인덱스`
(일반적인 인덱스는 논클러스터 인덱스라고 불림) 
-> 레코드의 저장이나 PK를 변경하는 것은 레코드가 저장된 물리적인 위치를 변경하는 작업이 수반되기 때문에 처리 속도가 느림 
> 이러한 특정을 갖는 인덱스를 사용하는 이유는 쓰기 작업을 희생해서 읽기 작업을 빠르게 하기 위함   
> 일반적으로 읽기와 쓰기 비율이 8:2 정도 된다고 함  
* MySQL에서는 기본적으로 PK가 없으면 내부적으로 PK 를 만들어내므로 모든 테이블이 클러스터링 테이블이라고 할 수 있음 
* 클러스터형 인덱스는 데이터 파일과 인덱스가 물리적으로 밀접
## 페이지 
디스크와 버퍼풀 메모리에 데이터를 읽고 쓰는 최소 작업 단위 
* 모든 인덱스와 테이블은 모두 페이지 단위로 관리됨 
* 쿼리를 통해 1개의 레코드를 읽고 싶어도 하나의 페이지를 읽어야함 -> 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여, 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 중요함
	* 디스크 I/O 를 통해 페이지를 읽어오면 버퍼풀이라는 메모리에 캐싱 -> 개별 데이터의 크기가 커지면 메모리에 캐싱해둘 수 있는 페이지 수도 줄어들게 되어 메모리 효율이 떨어짐
## 인덱스와 페이지의 관계
PK가 레코드의 물리적인 저장 위치를 결정하기 때문에, 인덱스는 PK에 의존 
![](%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202023-07-13%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.55.58.png)
PK 는 물리적인 저장 위치를 저장 -> pk로 검색 시 처리가 빠르고 연속된 데이터를 조회하는 경우에는 순차 I/O가 발생하여 훨씬 빠름
인덱스는 pk 값을 가지므로 pk만 조회하는 경우 내부 테이블까지 조회하지 않아도 되므로 효율적으로 처리 
### 단점
인덱스를 관리할 때 PK를 같이 저장하게 됨 -> PK가 클수록 다른 인덱스 구조도 커지면서 페이지가 많이 쪼개져 디스트 I/O 횟수가 증가하는 문제가 있음 

## PK 의 동작 
### PK 선택 방식 
1. PK를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 후보군이 없다면 내부적으로 자동 증가 유니크 컬럼을 추가한 후 클러스터링 키로 선택 
	* 3번으로 생성되는 내부 PK는 사용자에게 노출되지 않으며, 쿼리에서 사용할 수 없음 
	* 클러스터링 키는 테이블 당 하나만 가질 수 있으므로 반드시 생성해주는 것이 성능에 좋음 
### PK의 값을 변경하는 경우
PK가 변경되는 경우 레코드가 저장된 물리적인 위치도 변경되어야 함을 의미 -> PK 값에 따라 레코드가 있어야 하는 페이지가 달라질 수 있음 
단순히 값만 변경되는 것이 아니라 레코드를 삭제한 후에 삽입을 해주게 됨 -> 2번의 I/O 작업이 필요하고, 인덱스 쪽에서도 추가 작업을 유발할 수 있어 비용이 상당히 큼 
* PK 는 변하지 않는 값으로 설정하는 것이 중요! 

## 번외 : PK의 값이 AUTO_INCREMENT 와 UUID 일 때 성능 비교 
```sql 
create table innodb_auto_increment (
  id integer auto_increment not null,
  primary key (id)
) type=innodb;

create table innodb_integer (
  id integer not null,
  primary key (id)
) type=innodb;

create table innodb_uuid (
  id char(36),
  primary key (id)
) type=innodb;
```
* 테스트는 한 트랜잭션당 100,000개를 삽입하고 경과된 시간을 기록함 
* innodb_integer 테이블과 innodb_uuid 테이블의 id는 자바 코드에서 생성되고 전달됨 
![](initial-per-transaction.jpg) 1,500만개의 레코드가 있는 테이블에 레코드를 삽입하는 경우
![](initial-cumulative.jpg) 빈 테이블에 레코드를 삽입하는 경우
[MySQL InnoDB Primary Key Choice: GUID/UUID vs Integer Insert Performance	 :: KCCoder](https://kccoder.com/mysql/uuid-vs-int-insert-performance/)

## b-tree 구조에서 리프 노드까지..
![](img.jpg)
* 리프 노드를 제외한 루트 노드와 브랜치 노드에는 자식노드들의 첫 레코드값만 존재
	* 페이지 (1)에는 페이지 (2)의 첫 레코드 페이지 (3)의 첫 레코드가 존재 
* “Gad” 이라는 인덱스 레코드를 찾고 싶다면??
Gad은 Aamer 와 Jaana 사이에 있으므로 페이지 (2)에 있음 
-> 페이지 (2)에 가서 탐색 -> 어라라 찾았다 6번으로 가래! -> 6번 가서 다시 탐색
pk값을 얻었으면 pk 인덱스 구조로 가서 다시 탐색 반복해서 데이터 파일까지! 완료! 

### 인덱스 키 검색
select 뿐만 아니라 update delete 쿼리에서도 해당 레코드를 찾는데 인덱스가 사용됨 -> =, <, > 비교에 사용할 수 있고, 앞부분 일치를 이용한 검색에도 사용할 수 있으나 뒷부분 일치를 이용한 검색은 불가능 
### 인덱스에 영향을 미치는 요소
1. 인덱스 키 값의 크기 
각 노드에 담길 수 있는 인덱스의 개수는 각 노드가 가질 수 있는 인덱스 키 값의 크키와 연관이 되어 있음 주소를 가르키는 value는 고정적이기에 
-> 인덱스 키의 값의 크기가 커지면 하나의 노드가 가지고 있을 수 있는 인덱스의 키의 개수가 줄어들면서 효율이 떨어짐 
2. b-tree 의 깊이
사용자가 직접적으로 조절할 수 있는 방법은 없음 
레코드가 대용량이 될수록 깊이가 늘어나기 때문에 인덱스의 키 값의 크기를 줄여서 데이터가 많아지더라도 깊이가 빨리 늘어나지 않도록 하는 것이 최선의 방법
3. 읽어야하는 레코드 수
통계적인 수치로 전체 레코드 대비 20% 미만의 레코드를 읽을 때 효율적으로 동작 
(저장된 레코드 수와 읽어야할 레코드 수를 예상해서 옵티마이저가 최적화해줌) 
### 인덱스 스캔 종류 
조회에서 인덱스를 조회하기만 한다고 무조건 좋은 것은 아님
1. 인덱스 레인지 스캔
`SELECT * FROM employees WHERE first_name BETWEEN ‘Jeong’ AND ‘Pro’`
이러한 쿼리에서 first_name 컬럼으로 인덱스가 생성되어 있으면 인덱스에서 해당 범위에 해당하는 일부만 읽어서 검색하는 방법 -> 통상적으로 인덱스를 탔다라고 말함
2. 인덱스 풀 스캔
2-1 인덱스를 사용하긴.. 하는데.. 처음부터 끝까지 다 읽는 것 -> 인덱스를 이용했지만 효율적이지 않는 경우 
2-2 (A,B,C) 순서로 복합 인덱스를 구성했는데 A부터 아닌 B나 C컬럼으로 조회하는 경우 
		* 테이블보다 인덱스의 크기가 작기 때문에 테이블 풀 스캔보다 조금 더 나은 성능일 수도.. 그나마 정렬된 인덱스를 사용하기에..
3. 루스 인덱스 스캔
인덱스 레인지 스캔처럼 일부만 읽는데 한번에 읽는 것이 아니라 중간에 필요하지 않은 인덱스 키 값은 무시하고 듬성듬성 읽는 방법
특정 조건을 만족했을 때 사용할 수 있음 (나중에… 알아보자…)
4. 인덱스 스킵 스캔
`SELECT gender, birth_date FROM employees WHERE birth_date >= ‘1993-01-01’`
인덱스가 (gender, birth_date) 로 생성되어 있다면 일반적인 경우에는 인덱스를 사용할 수 없음 
인덱스 스킵 스캔을 활성화한 상태에서는 동일한 쿼리도 인덱스를 사용할 수 있음 
조건 1.  gender의 범위가 적다는 것을 알고 있을 때 
gender 컬럼에 kim, park 밖에 존재하지 않다면 mysql 에서 where 조건에 gender = ‘m’ and birth_date ≥ ‘1993-01-01’ 과 gender = ‘f’ and birth_date ≥ ‘1993-01-01’ 을 넣어줘서 두 쿼리를 각각 실행한 뒤에 결과를 합쳐버리는 방식으로 최적화를 해줌
조건 2. 커버링 인덱스인 경우
커버링 인덱스란 쿼리에서 필요한 데이터가 모두 인덱스에 존재할 때 
### 복합 인덱스
복합 인덱스를 구성하게 되면 정렬이 앞선 컬럼에 의존하여 정렬됨 -> 인덱스의 순서를 잘 고려해서 설계 
* 인덱스를 생성할 때 컬럼마다 정렬 방향(오름차순, 내림차순)을 지정해서 인덱스를 생성할 수 있음 (mysql 5.7이하 버전에서는 안됨) 
* 회사에서는 대부분 5.7 이하 버전을 사용하는 경우가 많기에 컬럼 정렬 방향을 섞어서 쓰지 않는 것이 좋음 
#### 복합 인덱스 효율 비교 
`SELECT * FROM dept_emp WHERE dept_no=‘d001’ AND emp_no >= 1000;` 
인덱스 1. (dept_emp, emp_no)
	* dept_emp 기준으로 우선 정렬되어 있기에 d001 값을 갖는 인덱스를 찾고 emp_no 가 1000보다 큰 부분을 찾으면 됨 (dept_no가 바뀌지 않을 때까지 쭉 읽으면)
인덱스 2. (emp_no, dept_emp)
	* emp_no 가 1000보다 큰 부분을 찾은 후 쭉 읽으면서 dept_no 가 d0001 이 맞는지 대조해야함 
* 두 인덱스를 비교하면 당연히 인덱스 1번의 경우가 좋음 1번 경우는 동등 비교로 인덱스를 찾는 범위를 좁히는데 도움을 줌 (2번의 경우는 쿼리에서 단순 조건에 맞는지 비교하는 용도로 쓰임, 실제로는 인덱스가 사용될 수도 있고 아닐수도 있고..) 
##### 인덱스를 사용할 수 없는 경우
* NOT-EQUAL로 비교된 경우 (“<>”, “NOT IN”, “NOT BETWEEN”, “IS NOT NULL”)
	* 인덱스의 구조에서 봤듯이 부정형은 어쩔 수 없이 범위를 좁히는 조건으로 사용할 수 없어 일일이 비교하는 조건 검사로 이용될 수밖에 없음
* LIKE 뒷부분 일치로 비교된 경우 (“%PRO”)
	* 앞을 기준으로 정렬되어 있기 때문에 뒷부분 일치는 인덱스를 사용할 수 없음
* 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우)
	* 값을 변환해야 하는 경우는 상관없지만 인덱스 컬럼의 타입을 변경해야 하는 WHERE 조건을 적용하면 인덱스를 이용할 수 없음 매번 변환을 해야 하기에…
* 문자열 데이터 타입의 콜레이션이 다른 경우
	* 인덱스 컬럼은 utf8인데 WHERE에 조건에 있는 값은 euckr인 경우에는 콜레이션이 다르므로 인덱스를 탈 수 없음
