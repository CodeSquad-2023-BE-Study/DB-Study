# MySQL 아키텍처
> ![](https://i.imgur.com/ZB0nloU.png)
> 출처: https://dev.mysql.com/doc/refman/8.0/en/pluggable-storage-overview.html

<br/>

## 1. 구조
- (초록색 부분) MySQL 접속 클라이언트: 접속 API 혹은 쉘 스크립트로 MySQL에 접속 가능
- (주황색 부분) MySQL 엔진: SQL 요청 처리
  - 쿼리 파서, 전처리기, 옵티마이저, 실행 엔진 등으로 구성
- (파란색 부분) MySQL 스토리지 엔진: 데이터를 실제로 디스크에 저장하거나, 디스크에 저장된 데이터를 읽어오는 역할
  - 엔진은 옵티마이저가 작성한 실행 계획에 따라 스토리지 엔진을 저적히 호출해서 쿼리 실행
- (보라색 부분) 운영체제, 하드웨어: 실제 테이블 데이터와 로그 데이터를 파일로 저장

<br/>

## 2. 쿼리 실행 과정
> ![](https://i.imgur.com/FS155Cs.png)
> 출처: https://www.oreilly.com/library/view/high-performance-mysql/9780596101718/ch04.html

### 1) 쿼리 캐시
- SQL 실행 결과를 메모리에 캐싱
- 동일 SQL 실행 시 이전 결과 즉시 반환
- 테이블의 데이터 변경 시 캐싱된 데이터 삭제
	- 캐싱 데이터 삭제 시, 쿼리 캐시에 접근하는 스레드에 Lock이 걸림
	- 이로 인해 동시 처리 성능이 저하됨
	- 그래서 해당 기능은 MySQL 8.0버전에서부터 삭제됨

### 2) 쿼리 파서
- SQL 문장을 토큰으로 쪼개서 트리로 만듦
- 이 과정에서 쿼리 문장의 기본 문법 오류를 체크함

```SQL
SELECT id, name FROM t_user WHERE status = 'ACTIVE' AND age > 18
```

> ![](https://i.imgur.com/kMEqxDM.png)
> 출처: https://shardingsphere.apache.org/document/5.1.1/en/reference/sharding/parse/

### 3) 전처리기
- Parse Tree를 기반으로 SQL의 문장 구조 체크
- Parse Tree의 각 토큰이 유효한지 체크
	- 토큰에 해당하는 테이블 이름이나 컬럼 등이 실제로 존재하는 값인지 체크
	- 접근 권한도 체크

### 4) 옵티마이저
- SQL 실행을 최적화해서 실행 계획 수립
- 최적화 방식:
	- **규칙 기반 최적화**
		- 옵티마이저에 내장된 우선순위에 따라 점수를 매겨 실행 계획 수립
	- **비용 기반 최적화**
		- SQL을 처리하는 다양한 방법을 마련해두고
		  각 작업의 비용과 대상 테이블의 통계 정보를 활용해서 실행 계획 수립

### 5) 쿼리 실행 엔진
- 옵티마이저가 만든 실행 계획대로 스토리지 엔진을 호출해서 레코드을 읽고 씀

### 6) 스토리지 엔진
- 쿼리 실행 엔진이 요청하는대로 디스크로 데이터를 저장하고, 디스크로부터 데이터를 읽어옴
- 핸들러 API에 의해 동작
- 플러그인 형태로 제공
	- 사용자는 원하는 엔진을 선택해서 사용할 수 있음
- 대표적으로 InnoDB, MyISAM 엔진이 있음

> 참고:
> 스토리지뿐만이 아니라 검색어 파서, 사용자 인증 모듈 등도 플러그인 형태로 제공하는데
> 플러그인은 몇가지 한계가 있음
>   - 플러그인 간 통신 불가
>   - MySQL 서버의 변수나 함수를 직접 호출하기 때문에 캡슐화 원칙 위반 ?
> MySQL 8.0부터는 플러그인 아키텍처를 보완환 컴포넌트 아키텍처를 제공함

<br/>

## 3. InnoDB 스토리지 엔진
> MySQL 8.0 버전
> ![](https://i.imgur.com/yfVhStr.png)
> 출처: https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html

- **특징**
	- PK에 의한 클러스터링
	- 트랜잭션 지원
		- MVCC
		- Redo & Undo Log
		- 레코드 단위 잠금
	- InnoDB 버퍼풀 & 어댑티브 해시 인덱스

### 1) PK에 의한 클러스터링
: PK를 기준으로 데이터를 묶어서 저장하는 것
- 다음과 같은 장점이 있음
	- 레코드를 PK 순으로 정렬해서 저장
	- PK 인덱스 자동 생성
	- PK를 통해서만 레코드에 접근 가능
	- PK를 통한 범위 검색이 매우 빠름
- 하지만 클러스터링 사용으로 인해 READ? WRITE? 성능은 저하됨 => 확인 필요
	- PK 값이 바뀌면, 레코드의 물리적 순서도 바꿔줘야 하기 때문??

> 일반적인 웹 서비스는 쓰기보다 읽기 요청이 훨씬 많기 때문에 쓰기 성능을 희생하고 읽기 성능을 얻는 클러스터링을 하는 것이 합리적

> PK를 지정하지 않으면 InnoDB가 내부적으로 PK를 자동 생성해서 클러스터링을 진행하는데 
> 이렇게 내부적으로 생성된 PK는 사용자가 사용할 수 없음
> 따라서 InnoDB를 사용할 때는 PK를 직접 설정해주는 것이 좋음

### 2-1) 트랜잭션 지원 - MVCC(Multi Version Concurrency Control)
- 기본적으로 Commit, Rollback 기능 제공
- MVCC 기능 제공

![](https://i.imgur.com/KvUlGd3.png)

- InnoDB 버퍼풀: 변경된 데이터를 디스크 반영 전 잠시 버퍼링하는 공간
- Undo Log: 변경되기 이전 데이터를 백업해두는 공간

#1 commit
버퍼풀에 새로 삽입한 레코드 생성
![](https://i.imgur.com/IdtJ3rt.png)

#1 이 상태에서 update 쿼리 날리면?

![](https://i.imgur.com/z0Im8wr.png)
버퍼풀에 있던 유재석의 취미는 `코딩`으로 변경
Undo Log에는 이전 취미 값 `독서` 는 id와 함께 Undo Log에 복사


#2 이 상태에서 다른 트랜잭션이 유재석 레코드를 조회하면?
![](https://i.imgur.com/HSZ3G2U.png)

데이터베이스에 설정된 트랜잭션 격리 수준에 따라 다름
- Read Uncommit 이면? Read Commit이면?

트랜잭션 격리 레벨에 따라 조회되는 데이터가 달라지게 하는 기술이 MVCC

Multi Version Concurrent Control: 다양한 버전이 동시에 관리된다는 뜻
- 위 예시에서 보면 취미가 서로 다른 유재석 레코드 2개가 버퍼풀과 언두 로그에서 동시에 관리되고 있었음
- MVCC를 통해 레코드에 잠금을 걸지 않고도 트랜잭션 격리 레벨에 따라 일관된 기를 할 수 있었음

### 2-2) 트랜잭션 지원 - Undo Log & Redo Log

| Undo Log                    | Redo Log |
|:--------------------------- |:-------- |
| 변경되기 이전 데이터를 백업 | 변경된 데이터를 백업(Commit) 완료된 데이터 |
| 트랜잭션 보장(Rollback 시 Undo Log에 백업된 데이터 복원 | 영속성 보장(서버 비정상 종료시, Redo Log에 백업된 데이터 복원) |
| 트랜잭션 격리 수준 보장(트랜잭션 격리 수준에 맞게, 백업된 데이터 변환)                            |          |

### 2-3) 트랜잭션 지원 - 레코드 단위 잠금
- (동시성 문제를 고려해) 레코드 단위로 잠금을 걸기 때문에 동시 처리 성능이 좋다.
- 레코드 자체를 잠그는 것이 아니라 인덱스를 잠근다.

예시)

![](https://i.imgur.com/UO400gF.png)
> 업데이트할 레코드를 검색할 때 사용된 인덱스 레코드가 잠긴다.

만약 인덱스가 없다면?

![](https://i.imgur.com/O57y67A.png)

만약 성+이름의 복합 인덱스가 있다면?

![](https://i.imgur.com/b9rhaMJ.png)

‼️ 인덱스를 어떻게 설정 하는지에 따라 레코드 잠금 범위가 달라질 수 있으니 InnoDB를 사용할 때는 
인덱스를 신중하게 설정하자!

### 3-1) 버퍼풀
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱해두는 공간
- 쓰기 작업을 지연시켜서 일괄적으로 작업을 처리해주기도 함

**데이터 캐싱**
- SQL 요청 결과를 일정한 크기의 페이지 단위로 캐싱
- 인덱스 정보와 데이터 파일을 메모리에 캐싱??
- 페이지 단위로 테이블 데이터를 관리
- 페이지 교체 알고리즘으로 LRU 사용

**쓰기 지연 버퍼**
- 변경된 데이터를 버퍼풀에 모았다가, 한 번에 디스크에 기록
- JAP 영속 컨텍스트의 쓰기 지연 SQL 저장소랑 비슷

> 참고:
> Insert, Update, Delete 명령으로 변경된 페이지를 더티 페이지라고 부름
> InnoDB는 더티 페이지들을 모았다가 주기적으로 이벤트를 발생시켜서 한번에 디스크에 반영함
> 이렇게 하는 것은 랜덤 I/O를 줄이기 위함

### 3-2) 어댑티브 해시 인덱스
TODO

<br/>

## 4. InnoDB vs MyISAM

### MyISAM 특징
- 클러스터링 지원 X
- 트랜잭션 지원 X
- 외래키 지원 X
- 테이블 단위 잠금
	- 동시에 처리에 불리
- 키 캐시 사용(인덱스 정보만 버퍼링)
- 전문 검색, 공간 좌표 검색 기능 지원

### 정리

|                           | InnoDB | MyISAM |
|:------------------------- |:------ |:------ |
| 클러스터링 테이블(인덱스) |    O    |    X    |
| 외래키 설정 지원          |    O    |    X    |
| 트랜잭션 지원             |    O    |    X    |
| Locking Level(잠금 방식)  |  레코드 단위 잠금      |  테이블 단위 잠금    |
| 데이터 캐싱                          |  버퍼풀 사용(인덱스, 테이블 데이터 캐싱)      | 키 캐시 사용(인덱스 캐싱)       |
